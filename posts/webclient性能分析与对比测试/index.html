<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>WebClient性能分析与对比测试 - J5land, 程序员, 广告行业, 云原生 | 这里是 J5land 的博客</title><meta name="author" content="">
<meta name="author-link" content="">
<meta name="description" content="背景
在Spring 5之前，如果我们想要调用其他系统提供的HTTP服务，我们通常可以使用Spring提供的RestTemplate来访问。RestTemplate用法很简单，但它的不足之处在于它的请求是同步阻塞模式，因此存在一定性能瓶颈，当然如果想要使用异步方式请求，也可以使用AsyncRestTemplate。
从Spring 5开始，Spring中全面引入了Reactive响应式编程，WebClient就属于Spring WebFlux 的一部分。WebClient的请求模式属于异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
因此，从Spring 5 开始，HTTP服务之间的通信方式我们可以考虑使用WebCLient来取代之前的RestTemplate。
WebClient 详解
WebClient特点
webClient是一个功能完善的HTTP请求客户端，支持以下内容：

非阻塞I/O
反应流回压（即消费者负载过高时，主动反馈生产者放慢速度的机制）
具有高并发性，硬件资源消耗更少
流程的API设计
同步与异步交互
流式传输支持

WebClient 开发配置
1 添加依赖
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
2 基础配置
WebClient 实例构造器可以设置一些基础的全局web请求配置信息，比如默认的cookie、header、baseUrl等。
WebClient.builder()
                .defaultCookie(&#34;kl&#34;,&#34;kl&#34;)
                .defaultUriVariables(ImmutableMap.of(&#34;name&#34;,&#34;kl&#34;))
                .defaultHeader(&#34;header&#34;,&#34;kl&#34;)
                .defaultHeaders(httpHeaders -&gt; {
                    httpHeaders.add(&#34;header1&#34;,&#34;kl&#34;);
                    httpHeaders.add(&#34;header2&#34;,&#34;kl&#34;);
                })
                .defaultCookies(cookie -&gt;{
                    cookie.add(&#34;cookie1&#34;,&#34;kl&#34;);
                    cookie.add(&#34;cookie2&#34;,&#34;kl&#34;);
                })
                .baseUrl(&#34;http://www.compay.com&#34;)
                .build();
3 底层依赖Netty库配置
通过配置Netty底层库，可以配置SSL安全链接、请求超时、读写超时等。
可以通过配置动态连接池，自定义突破这些默认配置。包括Netty的select线程和工作线程也可以自己设置。

最大连接数（maxConnections）：ConnectionProvider连接池的最大连接数选项，默认为ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS，即：2 * 可用处理器数（但最小值为 16），#2052

Reactor Netty 提供了两种创建客户端的方式

HttpClient.create()- 这使用预定义 ConnectionProvider的，它是这样创建的ConnectionProvider.create(name, 500)。这意味着500 maxConnections（这是在构建器中明确指定的ConnectionProvider）和1000 pendingAcquireMaxCount（这是ConnectionProvider构建器提供的默认值）
HttpClient.create(ConnectionProvider)- 用户提供自定义ConnectionProvider
JavaDoc：https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxConnections-int-




最大空闲时间（maxIdleTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_IDLE_TIME，默认无空闲时间
最大存活时间（maxLifeTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_LIFE_TIME
等待获取时间（pendingAcquireTimeout）：获取连接超时默认45000ms，即45秒
挂起的获取最大计数（pendingAcquireMaxCount）：获取的最大注册请求数以保留在挂起队列中当使用 -1 调用时，挂起队列将没有上限。默认为2 * max connections.

//最大连接数、最大空闲时间、最大存活时间、获取连接超时时间
//挂起的获取最大计数
//在后台被驱逐时间
ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(20000)
                .evictInBackground(Duration.ofSeconds(120)).build();

//配置Netty select线程
HttpClient httpClient = HttpClient.create(provider)
  							.tcpConfiguration(tcpClient -&gt; {
                     //指定Netty的select 和 work线程数量
                     LoopResources loop = LoopResources.create(&#34;kl-event-loop&#34;, 1, 4, true);
                     return tcpClient.doOnConnected(connection -&gt; {
                         //读写超时设置
                         connection.addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                                 .addHandlerLast(new WriteTimeoutHandler(10));
                     })
                       //连接超时设置
                       .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                       .option(ChannelOption.TCP_NODELAY, true)
                       .runOn(loop);
                 });

WebClient.builder().clientConnector(new ReactorClientHttpConnector(httpClient).build();
WebClient 使用上常见问题
1 PoolAcquirePendingLimitException
Pending acquire queue has reached its maximum size of 1000; nested exception is reactor.netty.internal.shaded.reactor.pool.PoolAcquirePendingLimitException: Pending acquire queue has reached its maximum size of 1000
WebClient需要一个HTTP客户端库来执行请求。
默认情况下，它使用Reactor Netty，客户端使用一个“固定”连接池，其中500个是活动通道的最大数量，1000个是允许保持在挂起状态的进一步通道获取尝试的最大数量。
只要创建的通道少于500个，并且由池管理，那么实现就会创建一个新通道。
当达到池中通道的最大数量时，最多会延迟（挂起）1000次获取通道的新尝试，直到通道再次返回到池中，并且会拒绝进一步尝试，并出现错误。
你有两个选择来解决这个问题，垂直扩展：增加连接池大小和/或获取队列长度，水平扩展：创建应用程序的其他实例。
1.1 垂直扩展：增加连接池大小和/或获取队列长度
ConnectionProvider connectionProvider = ConnectionProvider.builder(&#34;myConnectionPool&#34;)
        .maxConnections(&lt;your_desired_max_connections&gt;)
        .pendingAcquireMaxCount(&lt;your_desired_pending_queue_size&gt;)
        .build();
ReactorClientHttpConnector clientHttpConnector = new ReactorClientHttpConnector(HttpClient.create(connectionProvider));
WebClient.builder()
        .clientConnector(clientHttpConnector)
        .build();
1.2 水平扩展：创建应用程序的其他实例，并在实例之间平衡api调用的负载。
在计算连接池的大小时，值得考虑下游api调用的延迟。
connection_pool_size=tps * downstream_api_latency
tps（每秒事务数）
2 Connection reset by peer exception
Connection reset by peer exception
由于没有设置合理的连接池抛出的异常信息。
https://github.com/reactor/reactor-netty/issues/1774
构建HTTP请求示例
1 GET请求示例
URI构造时支持属性占位符，真实参数在入参时排序好就可以。同时可以通过accept设置媒体类型，以及编码。最终的结果值是通过Mono和Flux来接收的，在subscribe方法中订阅返回值。
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.get()
  .uri(&#34;/book/{id}.html&#34;, 123)
  .acceptCharset(StandardCharsets.UTF_8)
  .accept(MediaType.TEXT_HTML)
  .retrieve()
  .bodyToMono(String.class);
result.subscribe(System.err::println);
如果需要携带复杂的查询参数，可以通过UriComponentsBuilder构造出URL请求地址，如：
//定义query参数
MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();
params.add(&#34;name&#34;, &#34;daybreak&#34;);
//定义url参数
Map&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;();
uriVariables.put(&#34;id&#34;, 200);
String uri = UriComponentsBuilder.fromUriString(&#34;/book/{id}.html&#34;)
  .queryParams(params)
  .uriVariables(uriVariables)
  .toUriString();
2 POST请求示例
POST请求示例演示了一个同时包含表单参数和文件流数据
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
FormInserter formInserter = fromMultipartData(&#34;name&#34;,&#34;daybreak&#34;)
	.with(&#34;map&#34;,ImmutableMap.of(&#34;xx&#34;,&#34;xx&#34;))
	.with(&#34;file&#34;,new File(&#34;d://xxx.doc&#34;));
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
	.body(formInserter)
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
普通POST请求，直接通过bodyValue设置对象实例即可。不用FormInserter构造
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
  .bodyValue(ImmutableMap.of(&#34;name&#34;,&#34;daybreak&#34;))
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
3 同步返回结果
WebClient client =  WebClient.create(&#34;http://www.compay.com&#34;);
String result = client .get().uri(&#34;/book/{id}.html&#34;, 123)
	.retrieve()
	.bodyToMono(String.class)
	.block();
System.err.println(result);
4 异常处理
可以使用OnStatus根据status code进行异常适配。
可以使用doOnError异常适配
可以使用onErrorReturn返回指定默认返回值
WebClient webClient = WebClient.builder().baseUrl(&#34;https://api.compay.com&#34;)
        .defaultHeader(HttpHeaders.CONTENT_TYPE, &#34;application/json&#34;)
        .defaultHeader(HttpHeaders.USER_AGENT, &#34;Spring 5 WebClient&#34;)
        .build();
WebClient.ResponseSpec responseSpec = webClient.method(HttpMethod.GET)
        .uri(&#34;/user/list?sort={sortField}&#34;, &#34;updated&#34;)
        .retrieve();
Mono&lt;String&gt; mono = responseSpec
        .onStatus(e -&gt; e.is4xxClientError(),resp -&gt; {
            LOGGER.error(&#34;error:{},msg:{}&#34;,resp.statusCode().value(),resp.statusCode().getReasonPhrase());
            return Mono.error(new RuntimeException(resp.statusCode().value() &#43; &#34; : &#34; &#43; resp.statusCode().getReasonPhrase()));
        })
        .bodyToMono(String.class)
        .doOnError(WebClientResponseException.class, err -&gt; {
            LOGGER.info(&#34;ERROR status:{},msg:{}&#34;,err.getRawStatusCode(),err.getResponseBodyAsString());
            throw new RuntimeException(err.getMessage());
        })
        .onErrorReturn(&#34;fallback&#34;);
String result = mono.block();
LOGGER.info(&#34;result:{}&#34;,result);
性能对比测试
接下来我们进行性能对比测试。
在某个业务场景中我们使用了RestTemplate，借此分析下WebClient 与 RestTemplate 两者的性能实际表现，通过实际的案例性能对比，看看WebClient 是否有如此优秀。
业务场景说明
在我们的业务场景中，是一个异步处理的场景。当完成某项业务后，进行HTTP异步通知处理。这个也是在业务开发中比较场景的一种场景。
测试方案设计
延迟的负载测试分析
搭建待测试项目
    private AtomicInteger metrics = new AtomicInteger(0);

    @RequestMapping(value = &#34;/check&#34;, method = RequestMethod.GET)
    @ResponseBody
    public String check() throws InterruptedException {
        Thread.sleep(100L);
        return &#34;success_&#34; &#43; metrics.incrementAndGet();
    }
Caller设计
1 ThreadPoolTaskExecutor &#43; RestTemplate
通过线程组组合 RestTemplate 实现异步HTTP请求。
		private static final int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
    private static final int queueSize = 20000;	
	
		@Bean
    public TaskExecutor listenerExecutor() {
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(queueSize);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        return pool;
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

2 AsyncRestTemplate
原官方的线程组&#43;RestTemplate方法，在Spring5.0以及废弃，替换换WebClient。
		@Bean
    public AsyncRestTemplate asyncRestTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(100);
        factory.setReadTimeout(200);
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(20000);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        pool.initialize();
        factory.setTaskExecutor(pool);
        return new AsyncRestTemplate(factory);
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

WebClient：异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
		@Bean
    public WebClient webClient(){
        ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(1000).build();
        return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create(provider))).build();
    }

最大连接数（maxConnections）：200
最大空闲时间（maxIdleTime）：60s
最大存活时间（maxLifeTime）：60s
等待获取时间（pendingAcquireTimeout）：60s
挂起的获取最大计数（pendingAcquireMaxCount）：1000

测试结果分析
1 ThreadPoolTaskExecutor &#43; RestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
44
168
1
0
100
3


200
42
334
1
1
100
3


400
92
602
115
1
100
3


800
232
972
533
2
100
3


1200
232
1007
1175
2
150
4


1600
232
1003
1683
3
200
5




2 AsyncRestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
47
168
1
0
200
3


200
37
334
1
2
300-500
3


400
93
603
111
3
400-500
5


800
169
981
127
3
1000
5


1200
235
1633
215
3
1000
5


1600
235
1869
417
3
1000
5




3 Webclient



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率
信息




100
38
168
1
0
100
2



200
37
335
1
0
100
2



400
37
667
1
0
100
2



800
43
1334
1
0
100
3



1200
50
2000
1
0
110
4



1400
43
2326
1
0
120
5



1600
51
2632
1
0
130
5
PoolAcquirePendingLimitException


1800
44
3031
1
0
150
6
PoolAcquirePendingLimitException


2000
48
3334
1
0
200
7
PoolAcquirePendingLimitException


2400
51
4000
1
0
250
8
PoolAcquirePendingLimitException


3000
54
4994
1
0
500
10
PoolAcquirePendingLimitException


4000
83
6666
1
0
800
15
PoolAcquirePendingLimitException


5000
130
8308
1
0
1000
20
PoolAcquirePendingLimitException





压测结论
1.ThreadPoolTaskExecutor &#43; RestTemplate，用户并发量在800，吞吐量可以达到972/s，但是tomcat线程被打满，已经出现了延迟等待的现象（由于使用的是CallerRunsPolicy策略）。
2.AsyncRestTemplate，用户并发量在800，吞吐量981/s，线程数169基本也进入CallerRunsPolicy策略。
3.Webclient，用户并发量在1400，吞吐量2326/s，线程数、内存、cpu都相对问题，由于Webclient是异步非阻塞的，不能像线程池一样设置执行CallerRunsPolicy策略，当用户并发量1600达到性能瓶颈，开始触发PoolAcquirePendingLimitException异常，Webclient的弊端在业务的做好容量规划，做好对应的垂直、水平扩展以及失败情况的fallback。
总结
WebClient性能非常优异，同样能够以少量而固定的线程数处理高并发的Http请求，在基于Http的服务间通信方面，完全可以取代RestTemplate以及AsyncRestTemplate。
参考：

https://blog.51cto.com/liukang/2090211
https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2
" /><meta name="keywords" content='webclient, Java, 性能分析' /><meta itemprop="name" content="WebClient性能分析与对比测试">
<meta itemprop="description" content="背景
在Spring 5之前，如果我们想要调用其他系统提供的HTTP服务，我们通常可以使用Spring提供的RestTemplate来访问。RestTemplate用法很简单，但它的不足之处在于它的请求是同步阻塞模式，因此存在一定性能瓶颈，当然如果想要使用异步方式请求，也可以使用AsyncRestTemplate。
从Spring 5开始，Spring中全面引入了Reactive响应式编程，WebClient就属于Spring WebFlux 的一部分。WebClient的请求模式属于异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
因此，从Spring 5 开始，HTTP服务之间的通信方式我们可以考虑使用WebCLient来取代之前的RestTemplate。
WebClient 详解
WebClient特点
webClient是一个功能完善的HTTP请求客户端，支持以下内容：

非阻塞I/O
反应流回压（即消费者负载过高时，主动反馈生产者放慢速度的机制）
具有高并发性，硬件资源消耗更少
流程的API设计
同步与异步交互
流式传输支持

WebClient 开发配置
1 添加依赖
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
2 基础配置
WebClient 实例构造器可以设置一些基础的全局web请求配置信息，比如默认的cookie、header、baseUrl等。
WebClient.builder()
                .defaultCookie(&#34;kl&#34;,&#34;kl&#34;)
                .defaultUriVariables(ImmutableMap.of(&#34;name&#34;,&#34;kl&#34;))
                .defaultHeader(&#34;header&#34;,&#34;kl&#34;)
                .defaultHeaders(httpHeaders -&gt; {
                    httpHeaders.add(&#34;header1&#34;,&#34;kl&#34;);
                    httpHeaders.add(&#34;header2&#34;,&#34;kl&#34;);
                })
                .defaultCookies(cookie -&gt;{
                    cookie.add(&#34;cookie1&#34;,&#34;kl&#34;);
                    cookie.add(&#34;cookie2&#34;,&#34;kl&#34;);
                })
                .baseUrl(&#34;http://www.compay.com&#34;)
                .build();
3 底层依赖Netty库配置
通过配置Netty底层库，可以配置SSL安全链接、请求超时、读写超时等。
可以通过配置动态连接池，自定义突破这些默认配置。包括Netty的select线程和工作线程也可以自己设置。

最大连接数（maxConnections）：ConnectionProvider连接池的最大连接数选项，默认为ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS，即：2 * 可用处理器数（但最小值为 16），#2052

Reactor Netty 提供了两种创建客户端的方式

HttpClient.create()- 这使用预定义 ConnectionProvider的，它是这样创建的ConnectionProvider.create(name, 500)。这意味着500 maxConnections（这是在构建器中明确指定的ConnectionProvider）和1000 pendingAcquireMaxCount（这是ConnectionProvider构建器提供的默认值）
HttpClient.create(ConnectionProvider)- 用户提供自定义ConnectionProvider
JavaDoc：https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxConnections-int-




最大空闲时间（maxIdleTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_IDLE_TIME，默认无空闲时间
最大存活时间（maxLifeTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_LIFE_TIME
等待获取时间（pendingAcquireTimeout）：获取连接超时默认45000ms，即45秒
挂起的获取最大计数（pendingAcquireMaxCount）：获取的最大注册请求数以保留在挂起队列中当使用 -1 调用时，挂起队列将没有上限。默认为2 * max connections.

//最大连接数、最大空闲时间、最大存活时间、获取连接超时时间
//挂起的获取最大计数
//在后台被驱逐时间
ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(20000)
                .evictInBackground(Duration.ofSeconds(120)).build();

//配置Netty select线程
HttpClient httpClient = HttpClient.create(provider)
  							.tcpConfiguration(tcpClient -&gt; {
                     //指定Netty的select 和 work线程数量
                     LoopResources loop = LoopResources.create(&#34;kl-event-loop&#34;, 1, 4, true);
                     return tcpClient.doOnConnected(connection -&gt; {
                         //读写超时设置
                         connection.addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                                 .addHandlerLast(new WriteTimeoutHandler(10));
                     })
                       //连接超时设置
                       .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                       .option(ChannelOption.TCP_NODELAY, true)
                       .runOn(loop);
                 });

WebClient.builder().clientConnector(new ReactorClientHttpConnector(httpClient).build();
WebClient 使用上常见问题
1 PoolAcquirePendingLimitException
Pending acquire queue has reached its maximum size of 1000; nested exception is reactor.netty.internal.shaded.reactor.pool.PoolAcquirePendingLimitException: Pending acquire queue has reached its maximum size of 1000
WebClient需要一个HTTP客户端库来执行请求。
默认情况下，它使用Reactor Netty，客户端使用一个“固定”连接池，其中500个是活动通道的最大数量，1000个是允许保持在挂起状态的进一步通道获取尝试的最大数量。
只要创建的通道少于500个，并且由池管理，那么实现就会创建一个新通道。
当达到池中通道的最大数量时，最多会延迟（挂起）1000次获取通道的新尝试，直到通道再次返回到池中，并且会拒绝进一步尝试，并出现错误。
你有两个选择来解决这个问题，垂直扩展：增加连接池大小和/或获取队列长度，水平扩展：创建应用程序的其他实例。
1.1 垂直扩展：增加连接池大小和/或获取队列长度
ConnectionProvider connectionProvider = ConnectionProvider.builder(&#34;myConnectionPool&#34;)
        .maxConnections(&lt;your_desired_max_connections&gt;)
        .pendingAcquireMaxCount(&lt;your_desired_pending_queue_size&gt;)
        .build();
ReactorClientHttpConnector clientHttpConnector = new ReactorClientHttpConnector(HttpClient.create(connectionProvider));
WebClient.builder()
        .clientConnector(clientHttpConnector)
        .build();
1.2 水平扩展：创建应用程序的其他实例，并在实例之间平衡api调用的负载。
在计算连接池的大小时，值得考虑下游api调用的延迟。
connection_pool_size=tps * downstream_api_latency
tps（每秒事务数）
2 Connection reset by peer exception
Connection reset by peer exception
由于没有设置合理的连接池抛出的异常信息。
https://github.com/reactor/reactor-netty/issues/1774
构建HTTP请求示例
1 GET请求示例
URI构造时支持属性占位符，真实参数在入参时排序好就可以。同时可以通过accept设置媒体类型，以及编码。最终的结果值是通过Mono和Flux来接收的，在subscribe方法中订阅返回值。
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.get()
  .uri(&#34;/book/{id}.html&#34;, 123)
  .acceptCharset(StandardCharsets.UTF_8)
  .accept(MediaType.TEXT_HTML)
  .retrieve()
  .bodyToMono(String.class);
result.subscribe(System.err::println);
如果需要携带复杂的查询参数，可以通过UriComponentsBuilder构造出URL请求地址，如：
//定义query参数
MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();
params.add(&#34;name&#34;, &#34;daybreak&#34;);
//定义url参数
Map&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;();
uriVariables.put(&#34;id&#34;, 200);
String uri = UriComponentsBuilder.fromUriString(&#34;/book/{id}.html&#34;)
  .queryParams(params)
  .uriVariables(uriVariables)
  .toUriString();
2 POST请求示例
POST请求示例演示了一个同时包含表单参数和文件流数据
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
FormInserter formInserter = fromMultipartData(&#34;name&#34;,&#34;daybreak&#34;)
	.with(&#34;map&#34;,ImmutableMap.of(&#34;xx&#34;,&#34;xx&#34;))
	.with(&#34;file&#34;,new File(&#34;d://xxx.doc&#34;));
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
	.body(formInserter)
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
普通POST请求，直接通过bodyValue设置对象实例即可。不用FormInserter构造
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
  .bodyValue(ImmutableMap.of(&#34;name&#34;,&#34;daybreak&#34;))
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
3 同步返回结果
WebClient client =  WebClient.create(&#34;http://www.compay.com&#34;);
String result = client .get().uri(&#34;/book/{id}.html&#34;, 123)
	.retrieve()
	.bodyToMono(String.class)
	.block();
System.err.println(result);
4 异常处理
可以使用OnStatus根据status code进行异常适配。
可以使用doOnError异常适配
可以使用onErrorReturn返回指定默认返回值
WebClient webClient = WebClient.builder().baseUrl(&#34;https://api.compay.com&#34;)
        .defaultHeader(HttpHeaders.CONTENT_TYPE, &#34;application/json&#34;)
        .defaultHeader(HttpHeaders.USER_AGENT, &#34;Spring 5 WebClient&#34;)
        .build();
WebClient.ResponseSpec responseSpec = webClient.method(HttpMethod.GET)
        .uri(&#34;/user/list?sort={sortField}&#34;, &#34;updated&#34;)
        .retrieve();
Mono&lt;String&gt; mono = responseSpec
        .onStatus(e -&gt; e.is4xxClientError(),resp -&gt; {
            LOGGER.error(&#34;error:{},msg:{}&#34;,resp.statusCode().value(),resp.statusCode().getReasonPhrase());
            return Mono.error(new RuntimeException(resp.statusCode().value() &#43; &#34; : &#34; &#43; resp.statusCode().getReasonPhrase()));
        })
        .bodyToMono(String.class)
        .doOnError(WebClientResponseException.class, err -&gt; {
            LOGGER.info(&#34;ERROR status:{},msg:{}&#34;,err.getRawStatusCode(),err.getResponseBodyAsString());
            throw new RuntimeException(err.getMessage());
        })
        .onErrorReturn(&#34;fallback&#34;);
String result = mono.block();
LOGGER.info(&#34;result:{}&#34;,result);
性能对比测试
接下来我们进行性能对比测试。
在某个业务场景中我们使用了RestTemplate，借此分析下WebClient 与 RestTemplate 两者的性能实际表现，通过实际的案例性能对比，看看WebClient 是否有如此优秀。
业务场景说明
在我们的业务场景中，是一个异步处理的场景。当完成某项业务后，进行HTTP异步通知处理。这个也是在业务开发中比较场景的一种场景。
测试方案设计
延迟的负载测试分析
搭建待测试项目
    private AtomicInteger metrics = new AtomicInteger(0);

    @RequestMapping(value = &#34;/check&#34;, method = RequestMethod.GET)
    @ResponseBody
    public String check() throws InterruptedException {
        Thread.sleep(100L);
        return &#34;success_&#34; &#43; metrics.incrementAndGet();
    }
Caller设计
1 ThreadPoolTaskExecutor &#43; RestTemplate
通过线程组组合 RestTemplate 实现异步HTTP请求。
		private static final int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
    private static final int queueSize = 20000;	
	
		@Bean
    public TaskExecutor listenerExecutor() {
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(queueSize);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        return pool;
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

2 AsyncRestTemplate
原官方的线程组&#43;RestTemplate方法，在Spring5.0以及废弃，替换换WebClient。
		@Bean
    public AsyncRestTemplate asyncRestTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(100);
        factory.setReadTimeout(200);
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(20000);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        pool.initialize();
        factory.setTaskExecutor(pool);
        return new AsyncRestTemplate(factory);
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

WebClient：异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
		@Bean
    public WebClient webClient(){
        ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(1000).build();
        return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create(provider))).build();
    }

最大连接数（maxConnections）：200
最大空闲时间（maxIdleTime）：60s
最大存活时间（maxLifeTime）：60s
等待获取时间（pendingAcquireTimeout）：60s
挂起的获取最大计数（pendingAcquireMaxCount）：1000

测试结果分析
1 ThreadPoolTaskExecutor &#43; RestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
44
168
1
0
100
3


200
42
334
1
1
100
3


400
92
602
115
1
100
3


800
232
972
533
2
100
3


1200
232
1007
1175
2
150
4


1600
232
1003
1683
3
200
5




2 AsyncRestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
47
168
1
0
200
3


200
37
334
1
2
300-500
3


400
93
603
111
3
400-500
5


800
169
981
127
3
1000
5


1200
235
1633
215
3
1000
5


1600
235
1869
417
3
1000
5




3 Webclient



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率
信息




100
38
168
1
0
100
2



200
37
335
1
0
100
2



400
37
667
1
0
100
2



800
43
1334
1
0
100
3



1200
50
2000
1
0
110
4



1400
43
2326
1
0
120
5



1600
51
2632
1
0
130
5
PoolAcquirePendingLimitException


1800
44
3031
1
0
150
6
PoolAcquirePendingLimitException


2000
48
3334
1
0
200
7
PoolAcquirePendingLimitException


2400
51
4000
1
0
250
8
PoolAcquirePendingLimitException


3000
54
4994
1
0
500
10
PoolAcquirePendingLimitException


4000
83
6666
1
0
800
15
PoolAcquirePendingLimitException


5000
130
8308
1
0
1000
20
PoolAcquirePendingLimitException





压测结论
1.ThreadPoolTaskExecutor &#43; RestTemplate，用户并发量在800，吞吐量可以达到972/s，但是tomcat线程被打满，已经出现了延迟等待的现象（由于使用的是CallerRunsPolicy策略）。
2.AsyncRestTemplate，用户并发量在800，吞吐量981/s，线程数169基本也进入CallerRunsPolicy策略。
3.Webclient，用户并发量在1400，吞吐量2326/s，线程数、内存、cpu都相对问题，由于Webclient是异步非阻塞的，不能像线程池一样设置执行CallerRunsPolicy策略，当用户并发量1600达到性能瓶颈，开始触发PoolAcquirePendingLimitException异常，Webclient的弊端在业务的做好容量规划，做好对应的垂直、水平扩展以及失败情况的fallback。
总结
WebClient性能非常优异，同样能够以少量而固定的线程数处理高并发的Http请求，在基于Http的服务间通信方面，完全可以取代RestTemplate以及AsyncRestTemplate。
参考：

https://blog.51cto.com/liukang/2090211
https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2
"><meta itemprop="datePublished" content="2023-01-16T11:51:21+08:00" />
<meta itemprop="dateModified" content="2023-01-16T11:51:21+08:00" />
<meta itemprop="wordCount" content="4261">
<meta itemprop="keywords" content="webclient,Java,性能分析," /><meta property="og:title" content="WebClient性能分析与对比测试" />
<meta property="og:description" content="背景
在Spring 5之前，如果我们想要调用其他系统提供的HTTP服务，我们通常可以使用Spring提供的RestTemplate来访问。RestTemplate用法很简单，但它的不足之处在于它的请求是同步阻塞模式，因此存在一定性能瓶颈，当然如果想要使用异步方式请求，也可以使用AsyncRestTemplate。
从Spring 5开始，Spring中全面引入了Reactive响应式编程，WebClient就属于Spring WebFlux 的一部分。WebClient的请求模式属于异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
因此，从Spring 5 开始，HTTP服务之间的通信方式我们可以考虑使用WebCLient来取代之前的RestTemplate。
WebClient 详解
WebClient特点
webClient是一个功能完善的HTTP请求客户端，支持以下内容：

非阻塞I/O
反应流回压（即消费者负载过高时，主动反馈生产者放慢速度的机制）
具有高并发性，硬件资源消耗更少
流程的API设计
同步与异步交互
流式传输支持

WebClient 开发配置
1 添加依赖
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
2 基础配置
WebClient 实例构造器可以设置一些基础的全局web请求配置信息，比如默认的cookie、header、baseUrl等。
WebClient.builder()
                .defaultCookie(&#34;kl&#34;,&#34;kl&#34;)
                .defaultUriVariables(ImmutableMap.of(&#34;name&#34;,&#34;kl&#34;))
                .defaultHeader(&#34;header&#34;,&#34;kl&#34;)
                .defaultHeaders(httpHeaders -&gt; {
                    httpHeaders.add(&#34;header1&#34;,&#34;kl&#34;);
                    httpHeaders.add(&#34;header2&#34;,&#34;kl&#34;);
                })
                .defaultCookies(cookie -&gt;{
                    cookie.add(&#34;cookie1&#34;,&#34;kl&#34;);
                    cookie.add(&#34;cookie2&#34;,&#34;kl&#34;);
                })
                .baseUrl(&#34;http://www.compay.com&#34;)
                .build();
3 底层依赖Netty库配置
通过配置Netty底层库，可以配置SSL安全链接、请求超时、读写超时等。
可以通过配置动态连接池，自定义突破这些默认配置。包括Netty的select线程和工作线程也可以自己设置。

最大连接数（maxConnections）：ConnectionProvider连接池的最大连接数选项，默认为ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS，即：2 * 可用处理器数（但最小值为 16），#2052

Reactor Netty 提供了两种创建客户端的方式

HttpClient.create()- 这使用预定义 ConnectionProvider的，它是这样创建的ConnectionProvider.create(name, 500)。这意味着500 maxConnections（这是在构建器中明确指定的ConnectionProvider）和1000 pendingAcquireMaxCount（这是ConnectionProvider构建器提供的默认值）
HttpClient.create(ConnectionProvider)- 用户提供自定义ConnectionProvider
JavaDoc：https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxConnections-int-




最大空闲时间（maxIdleTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_IDLE_TIME，默认无空闲时间
最大存活时间（maxLifeTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_LIFE_TIME
等待获取时间（pendingAcquireTimeout）：获取连接超时默认45000ms，即45秒
挂起的获取最大计数（pendingAcquireMaxCount）：获取的最大注册请求数以保留在挂起队列中当使用 -1 调用时，挂起队列将没有上限。默认为2 * max connections.

//最大连接数、最大空闲时间、最大存活时间、获取连接超时时间
//挂起的获取最大计数
//在后台被驱逐时间
ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(20000)
                .evictInBackground(Duration.ofSeconds(120)).build();

//配置Netty select线程
HttpClient httpClient = HttpClient.create(provider)
  							.tcpConfiguration(tcpClient -&gt; {
                     //指定Netty的select 和 work线程数量
                     LoopResources loop = LoopResources.create(&#34;kl-event-loop&#34;, 1, 4, true);
                     return tcpClient.doOnConnected(connection -&gt; {
                         //读写超时设置
                         connection.addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                                 .addHandlerLast(new WriteTimeoutHandler(10));
                     })
                       //连接超时设置
                       .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                       .option(ChannelOption.TCP_NODELAY, true)
                       .runOn(loop);
                 });

WebClient.builder().clientConnector(new ReactorClientHttpConnector(httpClient).build();
WebClient 使用上常见问题
1 PoolAcquirePendingLimitException
Pending acquire queue has reached its maximum size of 1000; nested exception is reactor.netty.internal.shaded.reactor.pool.PoolAcquirePendingLimitException: Pending acquire queue has reached its maximum size of 1000
WebClient需要一个HTTP客户端库来执行请求。
默认情况下，它使用Reactor Netty，客户端使用一个“固定”连接池，其中500个是活动通道的最大数量，1000个是允许保持在挂起状态的进一步通道获取尝试的最大数量。
只要创建的通道少于500个，并且由池管理，那么实现就会创建一个新通道。
当达到池中通道的最大数量时，最多会延迟（挂起）1000次获取通道的新尝试，直到通道再次返回到池中，并且会拒绝进一步尝试，并出现错误。
你有两个选择来解决这个问题，垂直扩展：增加连接池大小和/或获取队列长度，水平扩展：创建应用程序的其他实例。
1.1 垂直扩展：增加连接池大小和/或获取队列长度
ConnectionProvider connectionProvider = ConnectionProvider.builder(&#34;myConnectionPool&#34;)
        .maxConnections(&lt;your_desired_max_connections&gt;)
        .pendingAcquireMaxCount(&lt;your_desired_pending_queue_size&gt;)
        .build();
ReactorClientHttpConnector clientHttpConnector = new ReactorClientHttpConnector(HttpClient.create(connectionProvider));
WebClient.builder()
        .clientConnector(clientHttpConnector)
        .build();
1.2 水平扩展：创建应用程序的其他实例，并在实例之间平衡api调用的负载。
在计算连接池的大小时，值得考虑下游api调用的延迟。
connection_pool_size=tps * downstream_api_latency
tps（每秒事务数）
2 Connection reset by peer exception
Connection reset by peer exception
由于没有设置合理的连接池抛出的异常信息。
https://github.com/reactor/reactor-netty/issues/1774
构建HTTP请求示例
1 GET请求示例
URI构造时支持属性占位符，真实参数在入参时排序好就可以。同时可以通过accept设置媒体类型，以及编码。最终的结果值是通过Mono和Flux来接收的，在subscribe方法中订阅返回值。
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.get()
  .uri(&#34;/book/{id}.html&#34;, 123)
  .acceptCharset(StandardCharsets.UTF_8)
  .accept(MediaType.TEXT_HTML)
  .retrieve()
  .bodyToMono(String.class);
result.subscribe(System.err::println);
如果需要携带复杂的查询参数，可以通过UriComponentsBuilder构造出URL请求地址，如：
//定义query参数
MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();
params.add(&#34;name&#34;, &#34;daybreak&#34;);
//定义url参数
Map&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;();
uriVariables.put(&#34;id&#34;, 200);
String uri = UriComponentsBuilder.fromUriString(&#34;/book/{id}.html&#34;)
  .queryParams(params)
  .uriVariables(uriVariables)
  .toUriString();
2 POST请求示例
POST请求示例演示了一个同时包含表单参数和文件流数据
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
FormInserter formInserter = fromMultipartData(&#34;name&#34;,&#34;daybreak&#34;)
	.with(&#34;map&#34;,ImmutableMap.of(&#34;xx&#34;,&#34;xx&#34;))
	.with(&#34;file&#34;,new File(&#34;d://xxx.doc&#34;));
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
	.body(formInserter)
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
普通POST请求，直接通过bodyValue设置对象实例即可。不用FormInserter构造
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
  .bodyValue(ImmutableMap.of(&#34;name&#34;,&#34;daybreak&#34;))
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
3 同步返回结果
WebClient client =  WebClient.create(&#34;http://www.compay.com&#34;);
String result = client .get().uri(&#34;/book/{id}.html&#34;, 123)
	.retrieve()
	.bodyToMono(String.class)
	.block();
System.err.println(result);
4 异常处理
可以使用OnStatus根据status code进行异常适配。
可以使用doOnError异常适配
可以使用onErrorReturn返回指定默认返回值
WebClient webClient = WebClient.builder().baseUrl(&#34;https://api.compay.com&#34;)
        .defaultHeader(HttpHeaders.CONTENT_TYPE, &#34;application/json&#34;)
        .defaultHeader(HttpHeaders.USER_AGENT, &#34;Spring 5 WebClient&#34;)
        .build();
WebClient.ResponseSpec responseSpec = webClient.method(HttpMethod.GET)
        .uri(&#34;/user/list?sort={sortField}&#34;, &#34;updated&#34;)
        .retrieve();
Mono&lt;String&gt; mono = responseSpec
        .onStatus(e -&gt; e.is4xxClientError(),resp -&gt; {
            LOGGER.error(&#34;error:{},msg:{}&#34;,resp.statusCode().value(),resp.statusCode().getReasonPhrase());
            return Mono.error(new RuntimeException(resp.statusCode().value() &#43; &#34; : &#34; &#43; resp.statusCode().getReasonPhrase()));
        })
        .bodyToMono(String.class)
        .doOnError(WebClientResponseException.class, err -&gt; {
            LOGGER.info(&#34;ERROR status:{},msg:{}&#34;,err.getRawStatusCode(),err.getResponseBodyAsString());
            throw new RuntimeException(err.getMessage());
        })
        .onErrorReturn(&#34;fallback&#34;);
String result = mono.block();
LOGGER.info(&#34;result:{}&#34;,result);
性能对比测试
接下来我们进行性能对比测试。
在某个业务场景中我们使用了RestTemplate，借此分析下WebClient 与 RestTemplate 两者的性能实际表现，通过实际的案例性能对比，看看WebClient 是否有如此优秀。
业务场景说明
在我们的业务场景中，是一个异步处理的场景。当完成某项业务后，进行HTTP异步通知处理。这个也是在业务开发中比较场景的一种场景。
测试方案设计
延迟的负载测试分析
搭建待测试项目
    private AtomicInteger metrics = new AtomicInteger(0);

    @RequestMapping(value = &#34;/check&#34;, method = RequestMethod.GET)
    @ResponseBody
    public String check() throws InterruptedException {
        Thread.sleep(100L);
        return &#34;success_&#34; &#43; metrics.incrementAndGet();
    }
Caller设计
1 ThreadPoolTaskExecutor &#43; RestTemplate
通过线程组组合 RestTemplate 实现异步HTTP请求。
		private static final int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
    private static final int queueSize = 20000;	
	
		@Bean
    public TaskExecutor listenerExecutor() {
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(queueSize);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        return pool;
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

2 AsyncRestTemplate
原官方的线程组&#43;RestTemplate方法，在Spring5.0以及废弃，替换换WebClient。
		@Bean
    public AsyncRestTemplate asyncRestTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(100);
        factory.setReadTimeout(200);
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(20000);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        pool.initialize();
        factory.setTaskExecutor(pool);
        return new AsyncRestTemplate(factory);
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

WebClient：异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
		@Bean
    public WebClient webClient(){
        ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(1000).build();
        return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create(provider))).build();
    }

最大连接数（maxConnections）：200
最大空闲时间（maxIdleTime）：60s
最大存活时间（maxLifeTime）：60s
等待获取时间（pendingAcquireTimeout）：60s
挂起的获取最大计数（pendingAcquireMaxCount）：1000

测试结果分析
1 ThreadPoolTaskExecutor &#43; RestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
44
168
1
0
100
3


200
42
334
1
1
100
3


400
92
602
115
1
100
3


800
232
972
533
2
100
3


1200
232
1007
1175
2
150
4


1600
232
1003
1683
3
200
5




2 AsyncRestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
47
168
1
0
200
3


200
37
334
1
2
300-500
3


400
93
603
111
3
400-500
5


800
169
981
127
3
1000
5


1200
235
1633
215
3
1000
5


1600
235
1869
417
3
1000
5




3 Webclient



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率
信息




100
38
168
1
0
100
2



200
37
335
1
0
100
2



400
37
667
1
0
100
2



800
43
1334
1
0
100
3



1200
50
2000
1
0
110
4



1400
43
2326
1
0
120
5



1600
51
2632
1
0
130
5
PoolAcquirePendingLimitException


1800
44
3031
1
0
150
6
PoolAcquirePendingLimitException


2000
48
3334
1
0
200
7
PoolAcquirePendingLimitException


2400
51
4000
1
0
250
8
PoolAcquirePendingLimitException


3000
54
4994
1
0
500
10
PoolAcquirePendingLimitException


4000
83
6666
1
0
800
15
PoolAcquirePendingLimitException


5000
130
8308
1
0
1000
20
PoolAcquirePendingLimitException





压测结论
1.ThreadPoolTaskExecutor &#43; RestTemplate，用户并发量在800，吞吐量可以达到972/s，但是tomcat线程被打满，已经出现了延迟等待的现象（由于使用的是CallerRunsPolicy策略）。
2.AsyncRestTemplate，用户并发量在800，吞吐量981/s，线程数169基本也进入CallerRunsPolicy策略。
3.Webclient，用户并发量在1400，吞吐量2326/s，线程数、内存、cpu都相对问题，由于Webclient是异步非阻塞的，不能像线程池一样设置执行CallerRunsPolicy策略，当用户并发量1600达到性能瓶颈，开始触发PoolAcquirePendingLimitException异常，Webclient的弊端在业务的做好容量规划，做好对应的垂直、水平扩展以及失败情况的fallback。
总结
WebClient性能非常优异，同样能够以少量而固定的线程数处理高并发的Http请求，在基于Http的服务间通信方面，完全可以取代RestTemplate以及AsyncRestTemplate。
参考：

https://blog.51cto.com/liukang/2090211
https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/webclient%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-16T11:51:21+08:00" />
<meta property="article:modified_time" content="2023-01-16T11:51:21+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="WebClient性能分析与对比测试"/>
<meta name="twitter:description" content="背景
在Spring 5之前，如果我们想要调用其他系统提供的HTTP服务，我们通常可以使用Spring提供的RestTemplate来访问。RestTemplate用法很简单，但它的不足之处在于它的请求是同步阻塞模式，因此存在一定性能瓶颈，当然如果想要使用异步方式请求，也可以使用AsyncRestTemplate。
从Spring 5开始，Spring中全面引入了Reactive响应式编程，WebClient就属于Spring WebFlux 的一部分。WebClient的请求模式属于异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
因此，从Spring 5 开始，HTTP服务之间的通信方式我们可以考虑使用WebCLient来取代之前的RestTemplate。
WebClient 详解
WebClient特点
webClient是一个功能完善的HTTP请求客户端，支持以下内容：

非阻塞I/O
反应流回压（即消费者负载过高时，主动反馈生产者放慢速度的机制）
具有高并发性，硬件资源消耗更少
流程的API设计
同步与异步交互
流式传输支持

WebClient 开发配置
1 添加依赖
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
2 基础配置
WebClient 实例构造器可以设置一些基础的全局web请求配置信息，比如默认的cookie、header、baseUrl等。
WebClient.builder()
                .defaultCookie(&#34;kl&#34;,&#34;kl&#34;)
                .defaultUriVariables(ImmutableMap.of(&#34;name&#34;,&#34;kl&#34;))
                .defaultHeader(&#34;header&#34;,&#34;kl&#34;)
                .defaultHeaders(httpHeaders -&gt; {
                    httpHeaders.add(&#34;header1&#34;,&#34;kl&#34;);
                    httpHeaders.add(&#34;header2&#34;,&#34;kl&#34;);
                })
                .defaultCookies(cookie -&gt;{
                    cookie.add(&#34;cookie1&#34;,&#34;kl&#34;);
                    cookie.add(&#34;cookie2&#34;,&#34;kl&#34;);
                })
                .baseUrl(&#34;http://www.compay.com&#34;)
                .build();
3 底层依赖Netty库配置
通过配置Netty底层库，可以配置SSL安全链接、请求超时、读写超时等。
可以通过配置动态连接池，自定义突破这些默认配置。包括Netty的select线程和工作线程也可以自己设置。

最大连接数（maxConnections）：ConnectionProvider连接池的最大连接数选项，默认为ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS，即：2 * 可用处理器数（但最小值为 16），#2052

Reactor Netty 提供了两种创建客户端的方式

HttpClient.create()- 这使用预定义 ConnectionProvider的，它是这样创建的ConnectionProvider.create(name, 500)。这意味着500 maxConnections（这是在构建器中明确指定的ConnectionProvider）和1000 pendingAcquireMaxCount（这是ConnectionProvider构建器提供的默认值）
HttpClient.create(ConnectionProvider)- 用户提供自定义ConnectionProvider
JavaDoc：https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxConnections-int-




最大空闲时间（maxIdleTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_IDLE_TIME，默认无空闲时间
最大存活时间（maxLifeTime）：默认ConnectionProvider.DEFAULT_POOL_MAX_LIFE_TIME
等待获取时间（pendingAcquireTimeout）：获取连接超时默认45000ms，即45秒
挂起的获取最大计数（pendingAcquireMaxCount）：获取的最大注册请求数以保留在挂起队列中当使用 -1 调用时，挂起队列将没有上限。默认为2 * max connections.

//最大连接数、最大空闲时间、最大存活时间、获取连接超时时间
//挂起的获取最大计数
//在后台被驱逐时间
ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(20000)
                .evictInBackground(Duration.ofSeconds(120)).build();

//配置Netty select线程
HttpClient httpClient = HttpClient.create(provider)
  							.tcpConfiguration(tcpClient -&gt; {
                     //指定Netty的select 和 work线程数量
                     LoopResources loop = LoopResources.create(&#34;kl-event-loop&#34;, 1, 4, true);
                     return tcpClient.doOnConnected(connection -&gt; {
                         //读写超时设置
                         connection.addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                                 .addHandlerLast(new WriteTimeoutHandler(10));
                     })
                       //连接超时设置
                       .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                       .option(ChannelOption.TCP_NODELAY, true)
                       .runOn(loop);
                 });

WebClient.builder().clientConnector(new ReactorClientHttpConnector(httpClient).build();
WebClient 使用上常见问题
1 PoolAcquirePendingLimitException
Pending acquire queue has reached its maximum size of 1000; nested exception is reactor.netty.internal.shaded.reactor.pool.PoolAcquirePendingLimitException: Pending acquire queue has reached its maximum size of 1000
WebClient需要一个HTTP客户端库来执行请求。
默认情况下，它使用Reactor Netty，客户端使用一个“固定”连接池，其中500个是活动通道的最大数量，1000个是允许保持在挂起状态的进一步通道获取尝试的最大数量。
只要创建的通道少于500个，并且由池管理，那么实现就会创建一个新通道。
当达到池中通道的最大数量时，最多会延迟（挂起）1000次获取通道的新尝试，直到通道再次返回到池中，并且会拒绝进一步尝试，并出现错误。
你有两个选择来解决这个问题，垂直扩展：增加连接池大小和/或获取队列长度，水平扩展：创建应用程序的其他实例。
1.1 垂直扩展：增加连接池大小和/或获取队列长度
ConnectionProvider connectionProvider = ConnectionProvider.builder(&#34;myConnectionPool&#34;)
        .maxConnections(&lt;your_desired_max_connections&gt;)
        .pendingAcquireMaxCount(&lt;your_desired_pending_queue_size&gt;)
        .build();
ReactorClientHttpConnector clientHttpConnector = new ReactorClientHttpConnector(HttpClient.create(connectionProvider));
WebClient.builder()
        .clientConnector(clientHttpConnector)
        .build();
1.2 水平扩展：创建应用程序的其他实例，并在实例之间平衡api调用的负载。
在计算连接池的大小时，值得考虑下游api调用的延迟。
connection_pool_size=tps * downstream_api_latency
tps（每秒事务数）
2 Connection reset by peer exception
Connection reset by peer exception
由于没有设置合理的连接池抛出的异常信息。
https://github.com/reactor/reactor-netty/issues/1774
构建HTTP请求示例
1 GET请求示例
URI构造时支持属性占位符，真实参数在入参时排序好就可以。同时可以通过accept设置媒体类型，以及编码。最终的结果值是通过Mono和Flux来接收的，在subscribe方法中订阅返回值。
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.get()
  .uri(&#34;/book/{id}.html&#34;, 123)
  .acceptCharset(StandardCharsets.UTF_8)
  .accept(MediaType.TEXT_HTML)
  .retrieve()
  .bodyToMono(String.class);
result.subscribe(System.err::println);
如果需要携带复杂的查询参数，可以通过UriComponentsBuilder构造出URL请求地址，如：
//定义query参数
MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();
params.add(&#34;name&#34;, &#34;daybreak&#34;);
//定义url参数
Map&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;();
uriVariables.put(&#34;id&#34;, 200);
String uri = UriComponentsBuilder.fromUriString(&#34;/book/{id}.html&#34;)
  .queryParams(params)
  .uriVariables(uriVariables)
  .toUriString();
2 POST请求示例
POST请求示例演示了一个同时包含表单参数和文件流数据
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
FormInserter formInserter = fromMultipartData(&#34;name&#34;,&#34;daybreak&#34;)
	.with(&#34;map&#34;,ImmutableMap.of(&#34;xx&#34;,&#34;xx&#34;))
	.with(&#34;file&#34;,new File(&#34;d://xxx.doc&#34;));
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
	.body(formInserter)
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
普通POST请求，直接通过bodyValue设置对象实例即可。不用FormInserter构造
WebClient client = WebClient.create(&#34;http://www.compay.com&#34;);
Mono&lt;String&gt; result = client.post().uri(&#34;/book/{id}.html&#34;, 123)
	.contentType(MediaType.APPLICATION_JSON)
  .bodyValue(ImmutableMap.of(&#34;name&#34;,&#34;daybreak&#34;))
	.retrieve()
	.bodyToMono(String.class);
result.subscribe(System.err::println);
3 同步返回结果
WebClient client =  WebClient.create(&#34;http://www.compay.com&#34;);
String result = client .get().uri(&#34;/book/{id}.html&#34;, 123)
	.retrieve()
	.bodyToMono(String.class)
	.block();
System.err.println(result);
4 异常处理
可以使用OnStatus根据status code进行异常适配。
可以使用doOnError异常适配
可以使用onErrorReturn返回指定默认返回值
WebClient webClient = WebClient.builder().baseUrl(&#34;https://api.compay.com&#34;)
        .defaultHeader(HttpHeaders.CONTENT_TYPE, &#34;application/json&#34;)
        .defaultHeader(HttpHeaders.USER_AGENT, &#34;Spring 5 WebClient&#34;)
        .build();
WebClient.ResponseSpec responseSpec = webClient.method(HttpMethod.GET)
        .uri(&#34;/user/list?sort={sortField}&#34;, &#34;updated&#34;)
        .retrieve();
Mono&lt;String&gt; mono = responseSpec
        .onStatus(e -&gt; e.is4xxClientError(),resp -&gt; {
            LOGGER.error(&#34;error:{},msg:{}&#34;,resp.statusCode().value(),resp.statusCode().getReasonPhrase());
            return Mono.error(new RuntimeException(resp.statusCode().value() &#43; &#34; : &#34; &#43; resp.statusCode().getReasonPhrase()));
        })
        .bodyToMono(String.class)
        .doOnError(WebClientResponseException.class, err -&gt; {
            LOGGER.info(&#34;ERROR status:{},msg:{}&#34;,err.getRawStatusCode(),err.getResponseBodyAsString());
            throw new RuntimeException(err.getMessage());
        })
        .onErrorReturn(&#34;fallback&#34;);
String result = mono.block();
LOGGER.info(&#34;result:{}&#34;,result);
性能对比测试
接下来我们进行性能对比测试。
在某个业务场景中我们使用了RestTemplate，借此分析下WebClient 与 RestTemplate 两者的性能实际表现，通过实际的案例性能对比，看看WebClient 是否有如此优秀。
业务场景说明
在我们的业务场景中，是一个异步处理的场景。当完成某项业务后，进行HTTP异步通知处理。这个也是在业务开发中比较场景的一种场景。
测试方案设计
延迟的负载测试分析
搭建待测试项目
    private AtomicInteger metrics = new AtomicInteger(0);

    @RequestMapping(value = &#34;/check&#34;, method = RequestMethod.GET)
    @ResponseBody
    public String check() throws InterruptedException {
        Thread.sleep(100L);
        return &#34;success_&#34; &#43; metrics.incrementAndGet();
    }
Caller设计
1 ThreadPoolTaskExecutor &#43; RestTemplate
通过线程组组合 RestTemplate 实现异步HTTP请求。
		private static final int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
    private static final int queueSize = 20000;	
	
		@Bean
    public TaskExecutor listenerExecutor() {
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(queueSize);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        return pool;
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

2 AsyncRestTemplate
原官方的线程组&#43;RestTemplate方法，在Spring5.0以及废弃，替换换WebClient。
		@Bean
    public AsyncRestTemplate asyncRestTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(100);
        factory.setReadTimeout(200);
        ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
        int poolSize = Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2;
        pool.setCorePoolSize(poolSize);
        pool.setMaxPoolSize(poolSize);
        pool.setQueueCapacity(20000);
        pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        pool.setWaitForTasksToCompleteOnShutdown(true);
        pool.setAwaitTerminationSeconds(60);
        pool.initialize();
        factory.setTaskExecutor(pool);
        return new AsyncRestTemplate(factory);
    }

corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2
queueCapacity：20000
rejectedExecutionHandler：CallerRunsPolicy

WebClient：异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。
		@Bean
    public WebClient webClient(){
        ConnectionProvider provider = ConnectionProvider.builder(&#34;fixed&#34;)
                .maxConnections(200)
                .maxIdleTime(Duration.ofSeconds(60))
                .maxLifeTime(Duration.ofSeconds(60))
                .pendingAcquireTimeout(Duration.ofSeconds(60))
                .pendingAcquireMaxCount(1000).build();
        return WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create(provider))).build();
    }

最大连接数（maxConnections）：200
最大空闲时间（maxIdleTime）：60s
最大存活时间（maxLifeTime）：60s
等待获取时间（pendingAcquireTimeout）：60s
挂起的获取最大计数（pendingAcquireMaxCount）：1000

测试结果分析
1 ThreadPoolTaskExecutor &#43; RestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
44
168
1
0
100
3


200
42
334
1
1
100
3


400
92
602
115
1
100
3


800
232
972
533
2
100
3


1200
232
1007
1175
2
150
4


1600
232
1003
1683
3
200
5




2 AsyncRestTemplate



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率




100
47
168
1
0
200
3


200
37
334
1
2
300-500
3


400
93
603
111
3
400-500
5


800
169
981
127
3
1000
5


1200
235
1633
215
3
1000
5


1600
235
1869
417
3
1000
5




3 Webclient



用户量
线程数
吞吐量(req/sec)
95%(ms)
延迟完成(min)
堆内存(Mb)
CPU占用率
信息




100
38
168
1
0
100
2



200
37
335
1
0
100
2



400
37
667
1
0
100
2



800
43
1334
1
0
100
3



1200
50
2000
1
0
110
4



1400
43
2326
1
0
120
5



1600
51
2632
1
0
130
5
PoolAcquirePendingLimitException


1800
44
3031
1
0
150
6
PoolAcquirePendingLimitException


2000
48
3334
1
0
200
7
PoolAcquirePendingLimitException


2400
51
4000
1
0
250
8
PoolAcquirePendingLimitException


3000
54
4994
1
0
500
10
PoolAcquirePendingLimitException


4000
83
6666
1
0
800
15
PoolAcquirePendingLimitException


5000
130
8308
1
0
1000
20
PoolAcquirePendingLimitException





压测结论
1.ThreadPoolTaskExecutor &#43; RestTemplate，用户并发量在800，吞吐量可以达到972/s，但是tomcat线程被打满，已经出现了延迟等待的现象（由于使用的是CallerRunsPolicy策略）。
2.AsyncRestTemplate，用户并发量在800，吞吐量981/s，线程数169基本也进入CallerRunsPolicy策略。
3.Webclient，用户并发量在1400，吞吐量2326/s，线程数、内存、cpu都相对问题，由于Webclient是异步非阻塞的，不能像线程池一样设置执行CallerRunsPolicy策略，当用户并发量1600达到性能瓶颈，开始触发PoolAcquirePendingLimitException异常，Webclient的弊端在业务的做好容量规划，做好对应的垂直、水平扩展以及失败情况的fallback。
总结
WebClient性能非常优异，同样能够以少量而固定的线程数处理高并发的Http请求，在基于Http的服务间通信方面，完全可以取代RestTemplate以及AsyncRestTemplate。
参考：

https://blog.51cto.com/liukang/2090211
https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2
"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://example.org/posts/webclient%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/" /><link rel="prev" href="http://example.org/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9C%8B%E7%9D%80%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" /><link rel="next" href="http://example.org/posts/docker%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "WebClient性能分析与对比测试",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/example.org\/posts\/webclient%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95\/"
    },"genre": "posts","keywords": "webclient, Java, 性能分析","wordcount":  4261 ,
    "url": "http:\/\/example.org\/posts\/webclient%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95\/","datePublished": "2023-01-16T11:51:21+08:00","dateModified": "2023-01-16T11:51:21+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "j5land"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="J5land, 程序员, 广告行业, 云原生 | 这里是 J5land 的博客"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/assets/avatar.png"
    data-srcset="/assets/avatar.png, /assets/avatar.png 1.5x, /assets/avatar.png 2x"
    data-sizes="auto"
    alt="J5land, 程序员, 广告行业, 云原生 | 这里是 J5land 的博客"
    title="J5land, 程序员, 广告行业, 云原生 | 这里是 J5land 的博客"/><span class="header-title-text">这里是 J5land 的博客</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li>
      </ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="J5land, 程序员, 广告行业, 云原生 | 这里是 J5land 的博客"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/assets/avatar.png"
    data-srcset="/assets/avatar.png, /assets/avatar.png 1.5x, /assets/avatar.png 2x"
    data-sizes="auto"
    alt="/assets/avatar.png"
    title="/assets/avatar.png"/><span class="header-title-text">这里是 J5land 的博客</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container" data-page-style="normal"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX">
        <span title="转载" class="icon-repost"><i class="fa-solid fa-share fa-fw" aria-hidden="true"></i></span><span>WebClient性能分析与对比测试</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><img
    class="lazyload avatar"
    src="/svg/loading.min.svg"
    data-src="/assets/avatar.png?s=32&amp;d=localhost:1313%25!%28EXTRA%20string=09f6ba2c1a27e4f0245271e28bf8417c,%20string=%29"
    data-srcset="/assets/avatar.png?s=32&amp;d=localhost:1313%25!%28EXTRA%20string=09f6ba2c1a27e4f0245271e28bf8417c%2c%20string=%29, /assets/avatar.png?s=32&amp;d=localhost:1313%25!%28EXTRA%20string=09f6ba2c1a27e4f0245271e28bf8417c%2c%20string=%29 1.5x, /assets/avatar.png?s=32&amp;d=localhost:1313%25!%28EXTRA%20string=09f6ba2c1a27e4f0245271e28bf8417c%2c%20string=%29 2x"
    data-sizes="auto"
    alt="j5land"
    title="j5land"/>&nbsp;j5land</span></span>
          <span class="post-category">收录于 <a href="/categories/java/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Java</a></span></div>
      <div class="post-meta-line"><span title=2023-01-16&#32;11:51:21><i class="fa-regular fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-01-16">2023-01-16</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i> 约 4261 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw" aria-hidden="true"></i> 预计阅读 9 分钟</span>&nbsp;</div>
    </div><div class="featured-image"><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="/posts/images/spring_webflux_preview.png"
    data-srcset="/posts/images/spring_webflux_preview.png, /posts/images/spring_webflux_preview.png 1.5x, /posts/images/spring_webflux_preview.png 2x"
    data-sizes="auto"
    alt="/posts/images/spring_webflux_preview.png"
    title="/posts/images/spring_webflux_preview.png"/></div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#webclient特点">WebClient特点</a></li>
  </ul>

  <ul>
    <li><a href="#1-添加依赖">1 添加依赖</a></li>
    <li><a href="#2-基础配置">2 基础配置</a></li>
    <li><a href="#3-底层依赖netty库配置">3 底层依赖Netty库配置</a>
      <ul>
        <li><a href="#webclient-使用上常见问题">WebClient 使用上常见问题</a></li>
        <li><a href="#2-connection-reset-by-peer-exception">2 Connection reset by peer exception</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-get请求示例">1 GET请求示例</a></li>
    <li><a href="#2-post请求示例">2 POST请求示例</a></li>
    <li><a href="#3-同步返回结果">3 同步返回结果</a></li>
    <li><a href="#4-异常处理">4 异常处理</a></li>
  </ul>

  <ul>
    <li><a href="#业务场景说明">业务场景说明</a></li>
    <li><a href="#测试方案设计">测试方案设计</a>
      <ul>
        <li><a href="#延迟的负载测试分析">延迟的负载测试分析</a></li>
        <li><a href="#caller设计">Caller设计</a></li>
      </ul>
    </li>
    <li><a href="#测试结果分析">测试结果分析</a>
      <ul>
        <li><a href="#1-threadpooltaskexecutor--resttemplate">1 ThreadPoolTaskExecutor + RestTemplate</a></li>
        <li><a href="#2-asyncresttemplate">2 AsyncRestTemplate</a></li>
        <li><a href="#3-webclient">3 Webclient</a></li>
        <li><a href="#压测结论">压测结论</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h1 id="背景">背景</h1>
<p>在Spring 5之前，如果我们想要调用其他系统提供的HTTP服务，我们通常可以使用Spring提供的RestTemplate来访问。RestTemplate用法很简单，但它的不足之处在于它的请求是同步阻塞模式，因此存在一定性能瓶颈，当然如果想要使用异步方式请求，也可以使用AsyncRestTemplate。</p>
<p>从Spring 5开始，Spring中全面引入了Reactive响应式编程，WebClient就属于Spring WebFlux 的一部分。WebClient的请求模式属于异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。</p>
<p>因此，从Spring 5 开始，HTTP服务之间的通信方式我们可以考虑使用WebCLient来取代之前的RestTemplate。</p>
<h1 id="webclient-详解">WebClient 详解</h1>
<h2 id="webclient特点">WebClient特点</h2>
<p>webClient是一个功能完善的HTTP请求客户端，支持以下内容：</p>
<ul>
<li>非阻塞I/O</li>
<li>反应流回压（即消费者负载过高时，主动反馈生产者放慢速度的机制）</li>
<li>具有高并发性，硬件资源消耗更少</li>
<li>流程的API设计</li>
<li>同步与异步交互</li>
<li>流式传输支持</li>
</ul>
<h1 id="webclient-开发配置">WebClient 开发配置</h1>
<h2 id="1-添加依赖">1 添加依赖</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-webflux<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><h2 id="2-基础配置">2 基础配置</h2>
<p>WebClient 实例构造器可以设置一些基础的全局web请求配置信息，比如默认的cookie、header、baseUrl等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">defaultCookie</span><span class="o">(</span><span class="s">&#34;kl&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">defaultUriVariables</span><span class="o">(</span><span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">defaultHeader</span><span class="o">(</span><span class="s">&#34;header&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">defaultHeaders</span><span class="o">(</span><span class="n">httpHeaders</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">httpHeaders</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;header1&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">httpHeaders</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;header2&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">})</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">defaultCookies</span><span class="o">(</span><span class="n">cookie</span> <span class="o">-&gt;{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cookie</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;cookie1&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cookie</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;cookie2&#34;</span><span class="o">,</span><span class="s">&#34;kl&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">})</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">baseUrl</span><span class="o">(</span><span class="s">&#34;http://www.compay.com&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h2 id="3-底层依赖netty库配置">3 底层依赖Netty库配置</h2>
<p>通过配置Netty底层库，可以配置SSL安全链接、请求超时、读写超时等。</p>
<p>可以通过配置动态连接池，自定义突破这些默认配置。包括Netty的select线程和工作线程也可以自己设置。</p>
<ul>
<li>最大连接数（maxConnections）：ConnectionProvider连接池的最大连接数选项，默认为<a href="https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.html#DEFAULT_POOL_MAX_CONNECTIONS"target="_blank" rel="external nofollow noopener noreferrer"><code>ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS</code></a>，即：2 * 可用处理器数（但最小值为 16），<a href="https://github.com/reactor/reactor-netty/issues/2052"target="_blank" rel="external nofollow noopener noreferrer">#2052</a>
<ul>
<li>Reactor Netty 提供了两种创建客户端的方式
<ul>
<li><code>HttpClient.create()</code>- 这使用<strong>预定义</strong> <code>ConnectionProvider</code>的，它是这样创建的<code>ConnectionProvider.create(name, 500)</code>。这意味着<code>500</code> <code>maxConnections</code>（这是在构建器中明确指定的<code>ConnectionProvider</code>）和<code>1000</code> <code>pendingAcquireMaxCount</code>（这是<code>ConnectionProvider</code>构建器提供的默认值）</li>
<li><code>HttpClient.create(ConnectionProvider)</code>- 用户提供自定义<code>ConnectionProvider</code></li>
<li>JavaDoc：https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxConnections-int-</li>
</ul>
</li>
</ul>
</li>
<li>最大空闲时间（maxIdleTime）：默认<a href="https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.html#DEFAULT_POOL_MAX_IDLE_TIME"target="_blank" rel="external nofollow noopener noreferrer"><code>ConnectionProvider.DEFAULT_POOL_MAX_IDLE_TIME</code></a>，默认无空闲时间</li>
<li>最大存活时间（maxLifeTime）：默认<a href="https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.html#DEFAULT_POOL_MAX_LIFE_TIME"target="_blank" rel="external nofollow noopener noreferrer"><code>ConnectionProvider.DEFAULT_POOL_MAX_LIFE_TIME</code></a></li>
<li>等待获取时间（pendingAcquireTimeout）：获取连接超时默认45000ms，即45秒</li>
<li>挂起的获取最大计数（pendingAcquireMaxCount）：获取的最大注册请求数以保留在挂起队列中当使用 -1 调用时，挂起队列将没有上限。默认为<code>2 * max connections</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//最大连接数、最大空闲时间、最大存活时间、获取连接超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1">//挂起的获取最大计数
</span></span></span><span class="line"><span class="cl"><span class="c1">//在后台被驱逐时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ConnectionProvider</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">ConnectionProvider</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">&#34;fixed&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxConnections</span><span class="o">(</span><span class="mi">200</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxIdleTime</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxLifeTime</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">pendingAcquireTimeout</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">pendingAcquireMaxCount</span><span class="o">(</span><span class="mi">20000</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">evictInBackground</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">120</span><span class="o">)).</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//配置Netty select线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="n">HttpClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">provider</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  							<span class="o">.</span><span class="na">tcpConfiguration</span><span class="o">(</span><span class="n">tcpClient</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">//指定Netty的select 和 work线程数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="n">LoopResources</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">LoopResources</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&#34;kl-event-loop&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                     <span class="k">return</span> <span class="n">tcpClient</span><span class="o">.</span><span class="na">doOnConnected</span><span class="o">(</span><span class="n">connection</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                         <span class="c1">//读写超时设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="n">connection</span><span class="o">.</span><span class="na">addHandlerLast</span><span class="o">(</span><span class="k">new</span> <span class="n">ReadTimeoutHandler</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">.</span><span class="na">addHandlerLast</span><span class="o">(</span><span class="k">new</span> <span class="n">WriteTimeoutHandler</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">                     <span class="o">})</span>
</span></span><span class="line"><span class="cl">                       <span class="c1">//连接超时设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">CONNECT_TIMEOUT_MILLIS</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                       <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">TCP_NODELAY</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                       <span class="o">.</span><span class="na">runOn</span><span class="o">(</span><span class="n">loop</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                 <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">WebClient</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">clientConnector</span><span class="o">(</span><span class="k">new</span> <span class="n">ReactorClientHttpConnector</span><span class="o">(</span><span class="n">httpClient</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="webclient-使用上常见问题">WebClient 使用上常见问题</h3>
<h4 id="1-poolacquirependinglimitexception">1 PoolAcquirePendingLimitException</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Pending</span> <span class="n">acquire</span> <span class="n">queue</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">its</span> <span class="n">maximum</span> <span class="n">size</span> <span class="n">of</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">nested</span> <span class="n">exception</span> <span class="n">is</span> <span class="n">reactor</span><span class="o">.</span><span class="na">netty</span><span class="o">.</span><span class="na">internal</span><span class="o">.</span><span class="na">shaded</span><span class="o">.</span><span class="na">reactor</span><span class="o">.</span><span class="na">pool</span><span class="o">.</span><span class="na">PoolAcquirePendingLimitException</span><span class="o">:</span> <span class="n">Pending</span> <span class="n">acquire</span> <span class="n">queue</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">its</span> <span class="n">maximum</span> <span class="n">size</span> <span class="n">of</span> <span class="mi">1000</span>
</span></span></code></pre></div><p>WebClient需要一个HTTP客户端库来执行请求。
默认情况下，它使用Reactor Netty，客户端使用一个“固定”连接池，其中500个是活动通道的最大数量，1000个是允许保持在挂起状态的进一步通道获取尝试的最大数量。</p>
<p>只要创建的通道少于500个，并且由池管理，那么实现就会创建一个新通道。
当达到池中通道的最大数量时，最多会延迟（挂起）1000次获取通道的新尝试，直到通道再次返回到池中，并且会拒绝进一步尝试，并出现错误。</p>
<p><strong>你有两个选择来解决这个问题，垂直扩展：增加连接池大小和/或获取队列长度，水平扩展：创建应用程序的其他实例。</strong></p>
<p>1.1 垂直扩展：增加连接池大小和/或获取队列长度</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ConnectionProvider</span> <span class="n">connectionProvider</span> <span class="o">=</span> <span class="n">ConnectionProvider</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">&#34;myConnectionPool&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">maxConnections</span><span class="o">(&lt;</span><span class="n">your_desired_max_connections</span><span class="o">&gt;)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">pendingAcquireMaxCount</span><span class="o">(&lt;</span><span class="n">your_desired_pending_queue_size</span><span class="o">&gt;)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">ReactorClientHttpConnector</span> <span class="n">clientHttpConnector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReactorClientHttpConnector</span><span class="o">(</span><span class="n">HttpClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">WebClient</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">clientConnector</span><span class="o">(</span><span class="n">clientHttpConnector</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></div><p>1.2 水平扩展：创建应用程序的其他实例，并在实例之间平衡api调用的负载。
在计算连接池的大小时，值得考虑下游api调用的延迟。
<code>connection_pool_size=tps * downstream_api_latency</code>
<code>tps（每秒事务数）</code></p>
<h3 id="2-connection-reset-by-peer-exception">2 Connection reset by peer exception</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Connection</span> <span class="n">reset</span> <span class="n">by</span> <span class="n">peer</span> <span class="n">exception</span>
</span></span></code></pre></div><p>由于没有设置合理的连接池抛出的异常信息。</p>
<p><a href="https://github.com/reactor/reactor-netty/issues/1774"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/reactor/reactor-netty/issues/1774</a></p>
<h1 id="构建http请求示例">构建HTTP请求示例</h1>
<h2 id="1-get请求示例">1 GET请求示例</h2>
<p>URI构造时支持属性占位符，真实参数在入参时排序好就可以。同时可以通过accept设置媒体类型，以及编码。最终的结果值是通过Mono和Flux来接收的，在subscribe方法中订阅返回值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&#34;http://www.compay.com&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Mono</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">&#34;/book/{id}.html&#34;</span><span class="o">,</span> <span class="mi">123</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">acceptCharset</span><span class="o">(</span><span class="n">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_HTML</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span></span></code></pre></div><p>如果需要携带复杂的查询参数，可以通过UriComponentsBuilder构造出URL请求地址，如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//定义query参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MultiValueMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedMultiValueMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">params</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;daybreak&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//定义url参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">uriVariables</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">uriVariables</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">UriComponentsBuilder</span><span class="o">.</span><span class="na">fromUriString</span><span class="o">(</span><span class="s">&#34;/book/{id}.html&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">queryParams</span><span class="o">(</span><span class="n">params</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">uriVariables</span><span class="o">(</span><span class="n">uriVariables</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">toUriString</span><span class="o">();</span>
</span></span></code></pre></div><h2 id="2-post请求示例">2 POST请求示例</h2>
<p>POST请求示例演示了一个同时包含表单参数和文件流数据</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&#34;http://www.compay.com&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FormInserter</span> <span class="n">formInserter</span> <span class="o">=</span> <span class="n">fromMultipartData</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span><span class="s">&#34;daybreak&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="s">&#34;map&#34;</span><span class="o">,</span><span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;xx&#34;</span><span class="o">,</span><span class="s">&#34;xx&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="s">&#34;file&#34;</span><span class="o">,</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;d://xxx.doc&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Mono</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">post</span><span class="o">().</span><span class="na">uri</span><span class="o">(</span><span class="s">&#34;/book/{id}.html&#34;</span><span class="o">,</span> <span class="mi">123</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="n">formInserter</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span></span></code></pre></div><p>普通POST请求，直接通过bodyValue设置对象实例即可。不用FormInserter构造</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&#34;http://www.compay.com&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Mono</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">post</span><span class="o">().</span><span class="na">uri</span><span class="o">(</span><span class="s">&#34;/book/{id}.html&#34;</span><span class="o">,</span> <span class="mi">123</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">bodyValue</span><span class="o">(</span><span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span><span class="s">&#34;daybreak&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span></span></code></pre></div><h2 id="3-同步返回结果">3 同步返回结果</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span> <span class="n">client</span> <span class="o">=</span>  <span class="n">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&#34;http://www.compay.com&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span> <span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">uri</span><span class="o">(</span><span class="s">&#34;/book/{id}.html&#34;</span><span class="o">,</span> <span class="mi">123</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">block</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span></span></code></pre></div><h2 id="4-异常处理">4 异常处理</h2>
<p>可以使用OnStatus根据status code进行异常适配。</p>
<p>可以使用doOnError异常适配</p>
<p>可以使用onErrorReturn返回指定默认返回值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">WebClient</span> <span class="n">webClient</span> <span class="o">=</span> <span class="n">WebClient</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">baseUrl</span><span class="o">(</span><span class="s">&#34;https://api.compay.com&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">defaultHeader</span><span class="o">(</span><span class="n">HttpHeaders</span><span class="o">.</span><span class="na">CONTENT_TYPE</span><span class="o">,</span> <span class="s">&#34;application/json&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">defaultHeader</span><span class="o">(</span><span class="n">HttpHeaders</span><span class="o">.</span><span class="na">USER_AGENT</span><span class="o">,</span> <span class="s">&#34;Spring 5 WebClient&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">WebClient</span><span class="o">.</span><span class="na">ResponseSpec</span> <span class="n">responseSpec</span> <span class="o">=</span> <span class="n">webClient</span><span class="o">.</span><span class="na">method</span><span class="o">(</span><span class="n">HttpMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">&#34;/user/list?sort={sortField}&#34;</span><span class="o">,</span> <span class="s">&#34;updated&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">retrieve</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Mono</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">mono</span> <span class="o">=</span> <span class="n">responseSpec</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">onStatus</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">is4xxClientError</span><span class="o">(),</span><span class="n">resp</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">LOGGER</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;error:{},msg:{}&#34;</span><span class="o">,</span><span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">().</span><span class="na">value</span><span class="o">(),</span><span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">().</span><span class="na">getReasonPhrase</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">Mono</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">().</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; : &#34;</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">().</span><span class="na">getReasonPhrase</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="o">})</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">doOnError</span><span class="o">(</span><span class="n">WebClientResponseException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;ERROR status:{},msg:{}&#34;</span><span class="o">,</span><span class="n">err</span><span class="o">.</span><span class="na">getRawStatusCode</span><span class="o">(),</span><span class="n">err</span><span class="o">.</span><span class="na">getResponseBodyAsString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">})</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">onErrorReturn</span><span class="o">(</span><span class="s">&#34;fallback&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mono</span><span class="o">.</span><span class="na">block</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;result:{}&#34;</span><span class="o">,</span><span class="n">result</span><span class="o">);</span>
</span></span></code></pre></div><h1 id="性能对比测试">性能对比测试</h1>
<p>接下来我们进行性能对比测试。</p>
<p>在某个业务场景中我们使用了RestTemplate，借此分析下WebClient 与 RestTemplate 两者的性能实际表现，通过实际的案例性能对比，看看WebClient 是否有如此优秀。</p>
<h2 id="业务场景说明">业务场景说明</h2>
<p>在我们的业务场景中，是一个异步处理的场景。当完成某项业务后，进行HTTP异步通知处理。这个也是在业务开发中比较场景的一种场景。</p>
<h2 id="测试方案设计">测试方案设计</h2>
<h3 id="延迟的负载测试分析">延迟的负载测试分析</h3>
<p>搭建待测试项目</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">AtomicInteger</span> <span class="n">metrics</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/check&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@ResponseBody</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">check</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100L</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;success_&#34;</span> <span class="o">+</span> <span class="n">metrics</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><h3 id="caller设计">Caller设计</h3>
<p>1 ThreadPoolTaskExecutor + RestTemplate</p>
<p>通过线程组组合 RestTemplate 实现异步HTTP请求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">		<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">poolSize</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">(),</span> <span class="mi">8</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">queueSize</span> <span class="o">=</span> <span class="mi">20000</span><span class="o">;</span>	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">		<span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">TaskExecutor</span> <span class="nf">listenerExecutor</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ThreadPoolTaskExecutor</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadPoolTaskExecutor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="n">poolSize</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="n">poolSize</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="n">queueSize</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setRejectedExecutionHandler</span><span class="o">(</span><span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">.</span><span class="na">CallerRunsPolicy</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setWaitForTasksToCompleteOnShutdown</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setAwaitTerminationSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pool</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><ul>
<li>corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2</li>
<li>maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2</li>
<li>queueCapacity：20000</li>
<li>rejectedExecutionHandler：CallerRunsPolicy</li>
</ul>
<p>2 AsyncRestTemplate</p>
<p>原官方的线程组+RestTemplate方法，在Spring5.0以及废弃，替换换WebClient。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">		<span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">AsyncRestTemplate</span> <span class="nf">asyncRestTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SimpleClientHttpRequestFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleClientHttpRequestFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">factory</span><span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">factory</span><span class="o">.</span><span class="na">setReadTimeout</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ThreadPoolTaskExecutor</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadPoolTaskExecutor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">poolSize</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">(),</span> <span class="mi">8</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="n">poolSize</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="n">poolSize</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">20000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setRejectedExecutionHandler</span><span class="o">(</span><span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">.</span><span class="na">CallerRunsPolicy</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setWaitForTasksToCompleteOnShutdown</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">setAwaitTerminationSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pool</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">factory</span><span class="o">.</span><span class="na">setTaskExecutor</span><span class="o">(</span><span class="n">pool</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">AsyncRestTemplate</span><span class="o">(</span><span class="n">factory</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><ul>
<li>corePoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2</li>
<li>maxPoolSize：Math.max(Runtime.getRuntime().availableProcessors(), 8) * 2</li>
<li>queueCapacity：20000</li>
<li>rejectedExecutionHandler：CallerRunsPolicy</li>
</ul>
<p>WebClient：异步非阻塞、反应式的，能够以少量固定的线程处理高并发的HTTP 请求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">		<span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">WebClient</span> <span class="nf">webClient</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ConnectionProvider</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">ConnectionProvider</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">&#34;fixed&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxConnections</span><span class="o">(</span><span class="mi">200</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxIdleTime</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">maxLifeTime</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">pendingAcquireTimeout</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">60</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">pendingAcquireMaxCount</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">WebClient</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">clientConnector</span><span class="o">(</span><span class="k">new</span> <span class="n">ReactorClientHttpConnector</span><span class="o">(</span><span class="n">HttpClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">provider</span><span class="o">))).</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><ul>
<li>最大连接数（maxConnections）：200</li>
<li>最大空闲时间（maxIdleTime）：60s</li>
<li>最大存活时间（maxLifeTime）：60s</li>
<li>等待获取时间（pendingAcquireTimeout）：60s</li>
<li>挂起的获取最大计数（pendingAcquireMaxCount）：1000</li>
</ul>
<h2 id="测试结果分析">测试结果分析</h2>
<h3 id="1-threadpooltaskexecutor--resttemplate">1 ThreadPoolTaskExecutor + RestTemplate</h3>
<table>
<thead>
<tr>
<th style="text-align:center">用户量</th>
<th style="text-align:center">线程数</th>
<th>吞吐量(req/sec)</th>
<th>95%(ms)</th>
<th>延迟完成(min)</th>
<th>堆内存(Mb)</th>
<th>CPU占用率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">44</td>
<td>168</td>
<td>1</td>
<td>0</td>
<td>100</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">42</td>
<td>334</td>
<td>1</td>
<td>1</td>
<td>100</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">92</td>
<td>602</td>
<td>115</td>
<td>1</td>
<td>100</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">800</td>
<td style="text-align:center">232</td>
<td>972</td>
<td>533</td>
<td>2</td>
<td>100</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">1200</td>
<td style="text-align:center">232</td>
<td>1007</td>
<td>1175</td>
<td>2</td>
<td>150</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:center">1600</td>
<td style="text-align:center">232</td>
<td>1003</td>
<td>1683</td>
<td>3</td>
<td>200</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../images/resttemplate.jpg"
    data-srcset="../images/resttemplate.jpg, ../images/resttemplate.jpg 1.5x, ../images/resttemplate.jpg 2x"
    data-sizes="auto"
    alt="resttemplate"
    title="resttemplate"/></p>
<h3 id="2-asyncresttemplate">2 AsyncRestTemplate</h3>
<table>
<thead>
<tr>
<th style="text-align:center">用户量</th>
<th style="text-align:center">线程数</th>
<th>吞吐量(req/sec)</th>
<th>95%(ms)</th>
<th>延迟完成(min)</th>
<th>堆内存(Mb)</th>
<th>CPU占用率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">47</td>
<td>168</td>
<td>1</td>
<td>0</td>
<td>200</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">37</td>
<td>334</td>
<td>1</td>
<td>2</td>
<td>300-500</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">93</td>
<td>603</td>
<td>111</td>
<td>3</td>
<td>400-500</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:center">800</td>
<td style="text-align:center">169</td>
<td>981</td>
<td>127</td>
<td>3</td>
<td>1000</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:center">1200</td>
<td style="text-align:center">235</td>
<td>1633</td>
<td>215</td>
<td>3</td>
<td>1000</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:center">1600</td>
<td style="text-align:center">235</td>
<td>1869</td>
<td>417</td>
<td>3</td>
<td>1000</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../images/async-resttemplate2.jpg"
    data-srcset="../images/async-resttemplate2.jpg, ../images/async-resttemplate2.jpg 1.5x, ../images/async-resttemplate2.jpg 2x"
    data-sizes="auto"
    alt="async-resttemplate2"
    title="async-resttemplate2"/></p>
<h3 id="3-webclient">3 Webclient</h3>
<table>
<thead>
<tr>
<th>用户量</th>
<th>线程数</th>
<th>吞吐量(req/sec)</th>
<th>95%(ms)</th>
<th>延迟完成(min)</th>
<th>堆内存(Mb)</th>
<th>CPU占用率</th>
<th style="text-align:center">信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>38</td>
<td>168</td>
<td>1</td>
<td>0</td>
<td>100</td>
<td>2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>200</td>
<td>37</td>
<td>335</td>
<td>1</td>
<td>0</td>
<td>100</td>
<td>2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>400</td>
<td>37</td>
<td>667</td>
<td>1</td>
<td>0</td>
<td>100</td>
<td>2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>800</td>
<td>43</td>
<td>1334</td>
<td>1</td>
<td>0</td>
<td>100</td>
<td>3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>1200</td>
<td>50</td>
<td>2000</td>
<td>1</td>
<td>0</td>
<td>110</td>
<td>4</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>1400</td>
<td>43</td>
<td>2326</td>
<td>1</td>
<td>0</td>
<td>120</td>
<td>5</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>1600</td>
<td>51</td>
<td>2632</td>
<td>1</td>
<td>0</td>
<td>130</td>
<td>5</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>1800</td>
<td>44</td>
<td>3031</td>
<td>1</td>
<td>0</td>
<td>150</td>
<td>6</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>2000</td>
<td>48</td>
<td>3334</td>
<td>1</td>
<td>0</td>
<td>200</td>
<td>7</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>2400</td>
<td>51</td>
<td>4000</td>
<td>1</td>
<td>0</td>
<td>250</td>
<td>8</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>3000</td>
<td>54</td>
<td>4994</td>
<td>1</td>
<td>0</td>
<td>500</td>
<td>10</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>4000</td>
<td>83</td>
<td>6666</td>
<td>1</td>
<td>0</td>
<td>800</td>
<td>15</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
<tr>
<td>5000</td>
<td>130</td>
<td>8308</td>
<td>1</td>
<td>0</td>
<td>1000</td>
<td>20</td>
<td style="text-align:center">PoolAcquirePendingLimitException</td>
</tr>
</tbody>
</table>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../images/webclient2.jpg"
    data-srcset="../images/webclient2.jpg, ../images/webclient2.jpg 1.5x, ../images/webclient2.jpg 2x"
    data-sizes="auto"
    alt="webclient2"
    title="webclient2"/></p>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../images/image-20230116151614439.png"
    data-srcset="../images/image-20230116151614439.png, ../images/image-20230116151614439.png 1.5x, ../images/image-20230116151614439.png 2x"
    data-sizes="auto"
    alt="image-20230116151614439"
    title="image-20230116151614439"/></p>
<h3 id="压测结论">压测结论</h3>
<p>1.ThreadPoolTaskExecutor + RestTemplate，用户并发量在800，吞吐量可以达到972/s，但是tomcat线程被打满，已经出现了延迟等待的现象（由于使用的是CallerRunsPolicy策略）。</p>
<p>2.AsyncRestTemplate，用户并发量在800，吞吐量981/s，线程数169基本也进入CallerRunsPolicy策略。</p>
<p>3.Webclient，用户并发量在1400，吞吐量2326/s，线程数、内存、cpu都相对问题，由于Webclient是异步非阻塞的，不能像线程池一样设置执行CallerRunsPolicy策略，当用户并发量1600达到性能瓶颈，开始触发PoolAcquirePendingLimitException异常，Webclient的弊端在业务的做好容量规划，做好对应的垂直、水平扩展以及失败情况的fallback。</p>
<h1 id="总结">总结</h1>
<p>WebClient性能非常优异，同样能够以少量而固定的线程数处理高并发的Http请求，在基于Http的服务间通信方面，完全可以取代RestTemplate以及AsyncRestTemplate。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.51cto.com/liukang/2090211"target="_blank" rel="external nofollow noopener noreferrer">https://blog.51cto.com/liukang/2090211</a></li>
<li><a href="https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2"target="_blank" rel="external nofollow noopener noreferrer">https://projectreactor.io/docs/netty/snapshot/reference/index.html#_connection_pool_2</a></li>
</ul></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title=2023-01-16&#32;11:51:21>更新于 2023-01-16&nbsp;</span>
      </div></div>
    <div class="post-info-line">
      <div class="post-info-md"></div>
      <div class="post-info-share">
        <span></span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/webclient/' class="post-tag">webclient</a><a href='/tags/java/' class="post-tag">Java</a><a href='/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/' class="post-tag">性能分析</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9C%8B%E7%9D%80%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" class="post-nav-item" rel="prev" title="微服务架构看着一篇就够了"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>微服务架构看着一篇就够了</a>
      <a href="/posts/docker%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/" class="post-nav-item" rel="next" title="Docker起源与容器技术原理">Docker起源与容器技术原理<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="giscus">
          <script
            src="https://giscus.app/client.js"
            data-repo="j5land/j5land.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxNjYxNTcwMjc="
            data-category="General"
            data-category-id="DIC_kwDOCeda484CUFrI"
            data-mapping="title"
            
            data-theme="preferred_color_scheme"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-lang="zh-CN"
            data-loading="lazy"
            crossorigin="anonymous"
            async
            defer
          ></script>
        </div>
        <noscript>
          Please enable JavaScript to view the comments powered by <a href="https://giscus.app/" rel="external nofollow noopener noreferrer">giscus</a>.
        </noscript></div></article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">Copyright © J5land Blog 2023
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class="site-time" title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中 ...</span></span></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div><div class="fixed-button view-comments d-none" role="button" aria-label="查看评论"><i class="fa-solid fa-comment fa-fw" aria-hidden="true"></i></div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/fuse/fuse.min.js" defer></script><script src="/lib/lazysizes/lazysizes.min.js" async defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":true,"expired":false,"giscus":{"darkTheme":"dark","lightTheme":"light"}},"search":{"distance":100,"findAllMatches":false,"highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":30,"threshold":0.3,"useExtendedSearch":false},"siteTime":"2020-05-23T16:15:22+08:00"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
